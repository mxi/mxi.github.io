#!/usr/bin/python
import os
import re
import sys
import markdown
from dataclasses import dataclass


manual = \
"""
SYNOPSIS
    impress - markdown article to HTML page converter.

    This tool is intended to be a pre-processor for the article linking
    tool, amalgam, which generates the article index using the article 
    card pages generated by impress.

COMPOSITION
    Impress takes as input a file consisting of three (3) sections
    separated by a blank line: (1) the header, (2) the brief summary,
    and (3) the markdown content.

    The header contains meta-information used by both the card and page
    templates to generate a specialized index entry and HTML page
    respectively. Header syntax consists of a simple key/value pair
    in the form `<key>: <value>`.

    The brief summary section consists of a single, multi-line paragraph
    describing the article in more detail. This tends to be included in
    the HTML card for the index.

    The markdown content composes the rest of the file and provides
    the body of the article. Impress uses the community Python package
    to compile markdown.

    Here is a sample document:

    |   header_key_1: value_1
    |   header_key_2: value_2
    |   ...
    >
    |   Here is a brief summary
    |   which may span multiple
    |   lines!
    >
    |   # Introduction
    |
    |   The remaining content is markdown.
    |   ...

    where `>` denotes the empty line section separators.

TEMPLATING
    Templates may substitute header information via the `@<key>@`
    syntax, where `key` references a key in the header table described
    above.

    Special key/value pairs, called automatic pairs, are appended
    to the header during runtime:

        path-input
            Relative path to the input file (-i flag).

        path-output
            Relative path to the output file (-o flag).

        brief
            Brief summary section content.

        content
            HTML converted markdown content.

USAGE
    impress [-tc file] [-tp file] [-dc dir] [-h] -i file -o file

ARGUMENTS
    -tc file
        Specifies the card template file. Defaults to 
        `.gen/template/card.html`.

    -tp file
        Specifies the page template file. Defaults to
        `.gen/template/page.html`.

    -dc dir
        Specifies the card destination directory, i.e. where card
        templates are rendered to. Defaults to `.gen/card/`.
    
    -h
        Print this manual.

    -i file
        Specifies the mandatory input file.

    -o file
        Specifies the mandatory output file.

AUTHOR
    (C) Maxim Kasyanenko, 2021. MIT License.
"""


def jointmessage(*items):
    return ' '.join(str(x) for x in items)


def perror(*items):
    sys.stderr.write(f'(ERROR) {jointmessage(*items)}\n')


def pwarn(*items):
    sys.stdout.write(f'(WARN) {jointmessage(*items)}\n')


def pinfo(*items):
    sys.stdout.write(f'(INFO) {jointmessage(*items)}\n')


def argvpop():
    return sys.argv.pop(0) if sys.argv else None


@dataclass
class Args: # refer to the manual above
    f_template_card: str = '.gen/template/card.html'
    f_template_page: str = '.gen/template/page.html'
    f_dest_card: str = '.gen/card/'
    f_input: str = None
    f_output: str = None
    fail_on_roam: bool = True
    help_: bool = False


def parseargs():
    args = Args()

    while sys.argv:
        word = argvpop()
        if   word == '-tc':
            args.f_template_card = argvpop()
        elif word == '-tp':
            args.f_template_page = argvpop()
        elif word == '-dc':
            args.f_dest_card = argvpop()
        elif word == '-i':
            args.f_input = argvpop()
        elif word == '-o':
            args.f_output = argvpop()
        elif word == '-r':
            args.fail_on_roam = False
        elif word == '-h':
            args.help_ = True

    return args


def main():
    # check for args
    a = parseargs()

    if a.help_:
        print(manual)
        return 0

    # f_input
    if not a.f_input:
        perror('input file must be specified.')
        perror('try: impress -h')
        return 1

    if not os.path.isfile(a.f_input):
        perror(f'input file "{a.f_input}" does not exist.')
        return 1

    # f_output
    if not a.f_output:
        perror('output file must be specified.')
        return 1

    # f_template_card
    if not a.f_template_card:
        perror('card template file must be specified.')
        return 1

    if not os.path.isfile(a.f_template_card):
        perror(f'card template "{a.f_template_card}" does not exist.')
        return 1

    # f_template_page
    if not a.f_template_page:
        perror('page template file must be specified.')
        return 1

    if not os.path.isfile(a.f_template_page):
        perror(f'page template "{a.f_template_page}" does not exist.')
        return 1

    # try to create directories of possible
    try:
        if a.f_dest_card:
            os.makedirs(a.f_dest_card, exist_ok=True)
    except OSError as e:
        perror('failed to create card destination directory:', e)
        return 1

    try:
        f_output_dir, _ = os.path.split(a.f_output)
        if f_output_dir:
            os.makedirs(f_output_dir, exist_ok=True)
    except OSError as e:
        perror('failed to create output parent directory:', e)
        return 1

    # setup for processing (used in header and elsewhere later)
    _, in_name = os.path.split(a.f_input)
    in_root, _ = os.path.splitext(in_name)

    # load in the template strings
    try:
        with open(a.f_template_card) as h_in:
            template_card = h_in.read()
        with open(a.f_template_page) as h_in:
            template_page = h_in.read()
    except OSError as e:
        perror('failed to read card/page template:', e)
        return 1

    # process the article
    with open(a.f_input) as h_in:
        # 
        article_header = dict()

        # firstly load in header
        for line in h_in:
            if line == '\n':
                break
            entry = [x.strip() for x in line.split(':', 1)]
            if len(entry) != 2:
                pwarn(f'line "{line}" is not a header entry!')
                continue
            key, value = entry
            article_header[key] = value

        # secondly, load in the `brief` description.
        article_brief_lines = []
        for line in h_in:
            if line == '\n':
                break
            article_brief_lines.append(line)
        article_brief = ' '.join(article_brief_lines)

        # lastly, load in the remaining `content` data, and pass it
        # through markdown.
        article_content = markdown.markdown(h_in.read())

    # automatic variables
    article_header['path-input'] = a.f_input
    article_header['path-output'] = a.f_output
    article_header['brief'] = article_brief
    article_header['content'] = article_content

    # perform the substitutions of the templates
    for key, value in article_header.items():
        target = f'@{key}@'
        template_card = template_card.replace(target, value)
        template_page = template_page.replace(target, value)

    # warn/fail on any non-substituted variables
    roam_pattern = re.compile(r'@[^@]*@')

    def findroaming(string, name):
        found = False
        for i, line in enumerate(string.split('\n')):
            n = i + 1
            matches = roam_pattern.findall(line)
            for match in matches:
                pwarn(f'{name}, line {n}: roaming {match}')
                found = True
        return found

    if (findroaming(template_card, 'card template') or \
        findroaming(template_page, 'page template')) and \
       a.fail_on_roam:
        perror('roaming variables in processed templates.')
        return 1

    # write out the populated templates
    try:
        with open(os.path.join(a.f_dest_card, f'{in_root}.html'), 'w') as h_out:
            h_out.write(template_card)
    except OSError as e:
        perror('failed to write card:', e)
        return 1

    try:
        with open(a.f_output, 'w') as h_out:
            h_out.write(template_page)
    except OSError as e:
        perror('failed to write page:', e)
        return 1

    #
    return 0


if __name__ == '__main__':
    exit(main())
